import os
import base64
import re
import logging
from typing import Optional, Dict, List
from dotenv import load_dotenv
from azure.devops.connection import Connection
from azure.identity import ManagedIdentityCredential, DefaultAzureCredential, InteractiveBrowserCredential
from msrest.authentication import BasicAuthentication
from azure.devops.v7_0.search.models import CodeSearchRequest
from azure.devops.v7_0.wiki.models import WikiPageCreateOrUpdateParameters, GitVersionDescriptor
from dataclasses import dataclass

# Load environment variables
load_dotenv()

@dataclass
class RepositorySearchConfig:
    """Configuration for repository-specific search settings"""
    name: str
    search_prefix: str = ""
    excluded_paths: List[str] = None
    included_paths: List[str] = None

    def __post_init__(self):
        if self.excluded_paths is None:
            self.excluded_paths = []
        if self.included_paths is None:
            self.included_paths = []

    def apply_prefix(self, search_text: str) -> str:
        """Apply repository-specific prefix to search text"""
        if not self.search_prefix:
            return search_text
        return f"{self.search_prefix} {search_text}"

    def should_exclude_path(self, path: str, agent_search: bool = False) -> bool:
        """Check if the path should be excluded based on repository rules"""
        path_lower = path.lower()
        
        # If included_paths is specified and agent_search is False, path must match one of them
        if self.included_paths and not agent_search:
            if not any(included in path_lower for included in self.included_paths):
                return True
                
        # Check excluded paths
        return any(excluded in path_lower for excluded in self.excluded_paths)

class AzureDevOpsSearch:
    def __init__(self, organization: str, project: str):
        """
        Initialize Azure DevOps search client
        
        Args:
            organization: Azure DevOps organization name
            project: Project name
        """
        self.organization = organization
        self.project = project
        self.knowledge_base = 'KnowledgeAutoGenerated'
        self.wiki_id = 'b499bcae-e563-4435-8427-585b129dd2f1'
        # Define repository configurations
        self.repository_configs = {
            "AdsAppsMT": RepositorySearchConfig(
                name="AdsAppsMT",
                search_prefix="(ext:cs)",
                excluded_paths=['test', 'proxy', 'proxies', 'campaignservice.cs'],
            ),
            "AdsAppsDB": RepositorySearchConfig(
                name="AdsAppsDB",
                search_prefix="(ext:sql)",
                included_paths=['prc_public']
            ),
            "AdsAppsCampaignUI": RepositorySearchConfig(
                name="AdsAppsCampaignUI",
                search_prefix="(ext:js OR ext:ts OR ext:jsx OR ext:tsx)",
                excluded_paths=['test', 'suite', 'tapi', 'demo']
            ),
            "AdsAppUISharedComponents": RepositorySearchConfig(
                name="AdsAppsCampaignUI",
                search_prefix="(ext:js OR ext:ts OR ext:jsx OR ext:tsx OR ext:es)",
                excluded_paths=['test', 'suite', 'tapi', 'demo']
            )
            # Add more repository configurations as needed
        }
        
        # Determine environment (production or development)
        environment = os.getenv('ENVIRONMENT', 'development').lower()
        
        # Select appropriate credential based on environment
        if environment == 'production' or environment == 'prod':
            # Use Managed Identity for production environments
            credential = ManagedIdentityCredential(client_id=os.getenv('CLIENT_ID'))
            print("Using ManagedIdentityCredential for production environment")
        else:
            # Use Interactive Browser for development environments
            credential = InteractiveBrowserCredential()
            print(f"Using InteractiveBrowserCredential for {environment} environment")
        
        # Get token for Azure DevOps
        self.token = credential.get_token("https://msasg.visualstudio.com//.default").token        
        
        # Create a connection to Azure DevOps using token
        basic_auth = BasicAuthentication('', self.token)
        self.connection = Connection(base_url=f"https://dev.azure.com/{organization}", creds=basic_auth)
        
        # Get search client
        self.search_client = self.connection.clients.get_search_client()

    def get_repository_config(self, repository_name: str) -> RepositorySearchConfig:
        """Get repository configuration, creating default if not exists"""
        return self.repository_configs.get(
            repository_name,
            RepositorySearchConfig(name=repository_name, excluded_paths=['test', 'proxy', 'proxies'])
        )

    def search_code(
        self,
        search_text: str,
        repository: Optional[str] = None,
        branch: Optional[str] = "master",
        agent_search: bool = False,
        max_results: int = 1000
    ) -> Dict:
        """
        Search code in Azure DevOps repositories
        
        Args:
            search_text: Text to search for
            repository: Optional repository name to search in
            branch: Branch to search in (default: master)
            max_results: Maximum number of results to return (default: 1000)
            
        Returns:
            Dictionary containing search results and status
        """
        # Create search request filter
        search_filters = {
            "Project": [self.project]
        }

        # Clean up search text for path matching by removing file extension filters and other special syntax
        clean_search_text = search_text.lower()
        
        # Apply repository-specific configuration if repository is specified
        if repository:
            repository_name = repository
                
            repo_config = self.get_repository_config(repository_name)
            search_text = repo_config.apply_prefix(search_text)
            search_filters["Repository"] = repository if isinstance(repository, list) else [repository]
            
        if branch:
            search_filters["Branch"] = [branch]
        
        # Create search request
        search_request = CodeSearchRequest(
            search_text=search_text,
            filters=search_filters,
            top=max_results,
            include_snippet=True
        )
        
        try:
            # Execute the search request
            response = self.search_client.fetch_code_search_results(search_request)
            
            # Filter results based on repository configuration
            filtered_results = []
            
            for result in response.results:
                if not repository:
                    # Use default exclusions for non-repository-specific search
                    if not any(excluded in result.path.lower() for excluded in ['test', 'proxy', 'proxies']):
                        filtered_results.append(result)
                else:
                    # Use repository-specific configuration
                    repo_name = result.repository.name if hasattr(result, 'repository') and hasattr(result.repository, 'name') else None
                    if repo_name:
                        repo_config = self.get_repository_config(repo_name)
                        if not repo_config.should_exclude_path(result.path, agent_search):
                            filtered_results.append(result)
            
            # Sort results by prioritizing search text in path, then by content matches
            filtered_results.sort(
                key=lambda x: (
                    -int(clean_search_text in x.path.lower()),  # Priority to files with search text in path
                    -len(x.matches.get('content', []))         # Secondary sort by content matches
                )
            )
            
            return {
                "status": "success",
                "results": filtered_results,
                "count": len(filtered_results),
                "search_text": search_text
            }
            
        except Exception as e:
            logging.error(f"Error in search_code: {str(e)}, search_text: {search_text}")
            return {
                "status": "error",
                "message": str(e),
                "search_text": search_text
            }

    
    def minify_code(self, code):
        code = re.sub(r'\n\s*\n+', '\n', code)

        code = '\n'.join(line.strip() for line in code.splitlines())

        return code
    
    def get_file_content(self, repository: str, file_path: str, branch: str = "master") -> Dict:
        """
        Get the content of a file from a repository
        
        Args:
            repository: Repository name
            file_path: Path to the file in the repository
            branch: Branch name (default: main)
            
        Returns:
            Dictionary containing the file content and status
        """
        try:
            # Get Git client
            git_client = self.connection.clients.get_git_client()
            
            # Get item content - using separate parameters instead of a dictionary for version control
            item = git_client.get_item_content(
                repository_id=repository,
                path=file_path,
                project=self.project,
            )
            
            # Try to decode as text (UTF-8)
            try:
                content = self.minify_code(b''.join(item).decode('utf-8'))
                is_binary = False
            except UnicodeDecodeError:
                # If it's not text, encode as base64
                is_binary = True
            
            return {
                "status": "success",
                "path": file_path,
                "length": len(content),
                "content": content,
            }
            
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "path": file_path,
                "repository": repository,
                "branch": branch
            }
    
    async def get_file_content_rest(self, repository: str, file_path: str, branch: str = "master") -> Dict:
        """
        Get the content of a file from a repository using REST API (async version with httpx)
        
        Args:
            repository: Repository name
            file_path: Path to the file in the repository
            branch: Branch name (default: master)
            
        Returns:
            Dictionary containing the file content and status
        """
        try:
            import httpx
            
            url = f"https://dev.azure.com/{self.organization}/{self.project}/_apis/git/repositories/{repository}/items"
            params = {
                "path": file_path,
                "versionDescriptor.version": branch,
                "includeContent": "true",
                "api-version": "7.1-preview.1"
            }
            headers = {
                "Authorization": f"Bearer {self.token}"
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.get(url, headers=headers, params=params)
                response.raise_for_status()
                content = self.minify_code(response.text)
                
                return {
                    "status": "success",
                    "path": file_path,
                    "length": len(content),
                    "content": content,
                }
            
        except Exception as e:
            logging.error(f"Error in get_file_content_rest: {str(e)}")
            content_result = self.get_file_content(repository, file_path, branch)
            if content_result["status"] == "success":
                logging.warning(f"fetch by get_file_content: {str(e)}")
                return content_result
            return {
                "status": "error",
                "message": str(e),
                "path": file_path,
                "repository": repository,
                "branch": branch
            }

    def get_wiki_client(self):
        """Get the Wiki client from Azure DevOps connection"""
        return self.connection.clients.get_wiki_client()

    def get_wikis(self) -> Dict:
        """
        Get all wikis in the project
        
        Returns:
            Dictionary containing the list of wikis and status
        """
        try:
            wiki_client = self.get_wiki_client()
            wikis = wiki_client.get_all_wikis(self.project)
            
            return {
                "status": "success",
                "wikis": wikis,
                "count": len(wikis)
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e)
            }

    def get_wiki_pages(self, wiki_id: str, path: str = "/") -> Dict:
        """
        Get wiki pages from a specific wiki
        
        Args:
            wiki_id: ID of the wiki
            path: Path in the wiki (default: root "/")
            
        Returns:
            Dictionary containing the wiki pages and status
        """
        try:
            wiki_client = self.get_wiki_client()
            pages = wiki_client.get_pages(wiki_id, path, recursion_level="full")
            
            return {
                "status": "success",
                "pages": pages,
                "count": len(pages)
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e)
            }

    def search_wiki(self, search_text: str, max_results: int = 1000) -> Dict:
        """
        Search within wiki pages
        
        Args:
            search_text: Text to search for in wikis
            path: Optional path to filter results (only include results with this path)
            max_results: Maximum number of results to return (default: 1000)
            
        Returns:
            Dictionary containing search results and status
        """
        try:
            search_client = self.search_client
            
            # Create wiki search request
            search_request = {
                "searchText": search_text,
                "filters": {
                    "Project": [self.project],
                    "Wiki": ["eh-campaign-platform-teams-doc"]  
                },
                "top": max_results,
            }
            
            # Execute the search request
            response = search_client.fetch_wiki_search_results(search_request)
            
            # Filter results if path is specified
            if response.results:
                filtered_results = [
                    result for result in response.results 
                    if hasattr(result, 'path') and self.knowledge_base in result.path
                ]
            else:
                filtered_results = response.results

            wiki_client = self.get_wiki_client()
            
            for search_result in filtered_results:
                # Decode the base64 content if it's binary
                processed_file_name = search_result.file_name.replace('-', ' ').replace('.md', '')

                existing_page = wiki_client.get_page(self.project, self.wiki_id, f'/{self.knowledge_base}/{processed_file_name}', include_content=True)
                if existing_page:
                    search_result.content = existing_page.page.content

            return {
                "status": "success",
                "results": filtered_results,
                "count": len(filtered_results) if filtered_results else 0,
                "search_text": search_text,
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "search_text": search_text,
            }

    def save_wiki_page(self, title: str, content: str) -> Dict:
        """
        Save or update a wiki page
        
        Args:
            wiki_id: ID of the wiki
            path: Path of the wiki page
            content: Content to save
            comment: Optional comment for the update
            
        Returns:
            Dictionary containing the save status and page info
        """
        try:
            wiki_client = self.get_wiki_client()
            path = f'/{self.knowledge_base}/{title}'
            version = ""
            try:
                existing_page = wiki_client.get_page(self.project, self.wiki_id, path)
                version = existing_page.eTag
            except Exception as e:
                # Page doesn't exist, will create new
                pass

            parameters = WikiPageCreateOrUpdateParameters(
                content=content
            )
            version_descriptor = GitVersionDescriptor(
                version="main",
                version_type="branch"  # could also be "tag" or "commit"
            )
            
            page = wiki_client.create_or_update_page(
                parameters=parameters,
                project=self.project,
                wiki_identifier=self.wiki_id,
                path=path,
                version_descriptor=version_descriptor,
                version=version,  # Empty string for new pages, eTag for existing
            )
            
            return {
                "status": "success",
                "page": page,
                "path": path,
                "message": "Page saved successfully"
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "path": path
            }

    def delete_wiki_page(self, page_id: str) -> Dict:
        """
        Delete a wiki page by its ID
        
        Args:
            page_id: ID of the wiki page to delete
            
        Returns:
            Dictionary containing the deletion status
        """
        try:
            wiki_client = self.get_wiki_client()
            
            # Delete the page by ID
            wiki_client.delete_page_by_id(
                project=self.project,
                wiki_identifier=self.wiki_id,
                id=page_id
            )
            
            return {
                "status": "success",
                "message": f"Wiki page with ID {page_id} deleted successfully",
                "page_id": page_id
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "page_id": page_id
            }

# Example usage
if __name__ == "__main__":
    # Initialize the search client using Azure CLI-based credentials
    search_client = AzureDevOpsSearch(
        organization=os.getenv('AZURE_DEVOPS_ORG'),
        project=os.getenv('AZURE_DEVOPS_PROJECT')
    )
    # path: /teams/CampaignMT/docs/team/Knowledge-Auto-Generated/
    # wikiid: b499bcae-e563-4435-8427-585b129dd2f1
    # search_client.search_wiki('video')
    res = search_client.save_wiki_page('video resource2', 'Test conten2t fss')

    search_client.delete_wiki_page(res['page'].page.id)
    # # Example 1: Search in all repositories
    # results = search_client.search_code(
    #     search_text="(ext:cs OR ext:sql) video",
    #     repository=["AdsAppsMT"],  # Search in specific repository
    #     branch="master"
    # )

    # bar = search_client.get_file_content_from_results(results)
    # print(bar)
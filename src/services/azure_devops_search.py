import os
import base64
import re
import logging
import time
from typing import Optional, Dict, List
from dotenv import load_dotenv
from azure.devops.connection import Connection
from azure.identity import ManagedIdentityCredential, DefaultAzureCredential, InteractiveBrowserCredential
from msrest.authentication import BasicAuthentication
from src.utils import is_raw_query
from azure.devops.v7_0.search.models import CodeSearchRequest
from azure.devops.v7_0.wiki.models import WikiPageCreateOrUpdateParameters, GitVersionDescriptor, WikiPagesBatchRequest
from src.configs.repository_configs import get_repository_config

# Load environment variables
load_dotenv()

class AzureDevOpsSearch:
    def __init__(self):
        """
        Initialize Azure DevOps search client
        
        Args:
            organization: Azure DevOps organization name
            project: Project name
        """
        self.knowledge_base = 'KnowledgeAutoGenerated'
        self.wiki_id = 'b499bcae-e563-4435-8427-585b129dd2f1'
        self.default_organization = os.getenv('AZURE_DEVOPS_ORG')
        self.default_project = os.getenv('AZURE_DEVOPS_PROJECT')
        
        # Initialize dictionaries for repository-specific properties
        self.tokens = {}
        self.connections = {}
        self.search_clients = {}
        self.token_created_at = {}
        
        # Determine environment (production or development)
        environment = os.getenv('ENVIRONMENT', 'development').lower()
        
        # Select appropriate credential based on environment
        if environment == 'production' or environment == 'prod':
            # Use Managed Identity for production environments
            self.credential = ManagedIdentityCredential(client_id=os.getenv('CLIENT_ID'))
            print("Using ManagedIdentityCredential for production environment")
        else:
            # Use Interactive Browser for development environments
            self.credential = DefaultAzureCredential()
            print(f"Using InteractiveBrowserCredential for {environment} environment")

    def _refresh_connection(self, repository_name: str):
        """Refresh the Azure DevOps token and connection for a specific repository
        
        Args:
            repository_name: Name of the repository to refresh connection for
        """
        repo_config = get_repository_config(repository_name)
        organization = repo_config.organization
        
        # Get new token for Azure DevOps
        self.tokens[repository_name] = self.credential.get_token('499b84ac-1321-427f-aa17-267ca6975798/.default').token
        logging.info(f"Token for {repository_name} created at {time.time()}, token: {self.tokens[repository_name]}")
        # Create a connection to Azure DevOps using token
        basic_auth = BasicAuthentication('', self.tokens[repository_name])
        self.connections[repository_name] = Connection(base_url=f"https://dev.azure.com/{organization}", creds=basic_auth)
        
        # Get search client
        self.search_clients[repository_name] = self.connections[repository_name].clients.get_search_client()
        
        # Store token creation time
        self.token_created_at[repository_name] = time.time()
        logging.info(f"Azure DevOps token refreshed for repository: {repository_name}")    

    def _ensure_valid_token(self, repository_name: str = 'AdsAppsMT'):
        """Check if token is about to expire and refresh if needed
        
        Args:
            repository_name: Name of the repository to check token for
        """
        # Initialize connection if it doesn't exist
        if repository_name not in self.token_created_at:
            self._refresh_connection(repository_name)
            return
            
        # Refresh token if it's older than 45 minutes (before the typical 1 hour expiry)
        if time.time() - self.token_created_at.get(repository_name, 0) > 45 * 60:
            logging.info(f"Token is about to expire for repository {repository_name}, refreshing...")
            self._refresh_connection(repository_name)

    def search_code(
        self,
        search_text: str,
        repository: Optional[str] = None,
        branch: Optional[str] = None,
        agent_search: bool = False,
        max_results: int = 1000,
        without_prefix: bool = False
    ) -> Dict:
        """
        Search code in Azure DevOps repositories
        
        Args:
            search_text: Text to search for
            repository: Optional repository name to search in
            branch: Branch to search in (overrides repository default if provided)
            agent_search: Whether the search is performed by an agent (default: False)
            max_results: Maximum number of results to return (default: 1000)
            without_prefix: If True, repository-specific prefix will not be applied (default: False)
            
        Returns:
            Dictionary containing search results and status
        """
        self._ensure_valid_token(repository)
        
        # Get repository-specific configuration
        repo_config = get_repository_config(repository)
        project = repo_config.project
        
        # Create search request filter
        search_filters = {
            "Project": [project]
        }
        
        # Clean up search text for path matching by removing file extension filters and other special syntax
        clean_search_text = search_text.lower()
        
        # Check if this is a raw query without special filters like path:, ext:, def:
        is_raw = is_raw_query(clean_search_text)
        logging.info(f"Query is raw (without filters): {is_raw}")
        
          # Apply repository-specific configuration if repository is specified
        if repository:
            repository_name = repository
            repo_config = get_repository_config(repository_name)
            
            # Only apply prefix if without_prefix is False
            if not without_prefix and is_raw:
                search_text = repo_config.apply_prefix(search_text)
            search_filters["Repository"] = repository if isinstance(repository, list) else [repository]
            
            # Use provided branch or fall back to repository's configured branch
            used_branch = branch if branch is not None else repo_config.branch
            search_filters["Branch"] = [used_branch]
        
        logging.info(f"Searching in repository: {repository}, branch: {branch}, search_text: {search_text}, filters: {search_filters}")

        # Create search request
        search_request = CodeSearchRequest(
            search_text=search_text,
            filters=search_filters,
            top=max_results,
            include_snippet=True
        )
        
        try:
            # Execute the search request using repository-specific client
            response = self.search_clients[repository].fetch_code_search_results(search_request)
            
            logging.info(f"Search response count: {response.count}")

            # Filter results based on repository configuration
            filtered_results = []
            
            if is_raw:
                for result in response.results:
                    result_repo_name = result.repository.name if hasattr(result, 'repository') and hasattr(result.repository, 'name') else None
                    if result_repo_name:
                        repo_config = get_repository_config(result_repo_name)
                        if not repo_config.should_exclude_path(result.path, agent_search):
                            filtered_results.append(result)
            else:
                filtered_results = response.results
            
            # Sort results by prioritizing search text in path, then by content matches
            filtered_results.sort(
                key=lambda x: (
                    -int(clean_search_text in x.path.lower()),  # Priority to files with search text in path
                    -len(x.matches.get('content', []))         # Secondary sort by content matches
                )
            )
            
            return {
                "status": "success",
                "results": filtered_results,
                "count": len(filtered_results),
                "search_text": search_text
            }
            
        except Exception as e:
            logging.error(f"Error in search_code: {str(e)}, search_text: {search_text}")
            return {
                "status": "error",
                "message": str(e),
                "search_text": search_text
            }

    def minify_code(self, code):
        code = re.sub(r'\n\s*\n+', '\n', code)

        code = '\n'.join(line.strip() for line in code.splitlines())

        return code

    def get_file_content(self, repository: str, file_path: str, branch: Optional[str] = None) -> Dict:
        """
        Get the content of a file from a repository
        
        Args:
            repository: Repository name
            file_path: Path to the file in the repository
            branch: Branch name (overrides repository default if provided)
            
        Returns:
            Dictionary containing the file content and status
        """
        self._ensure_valid_token(repository)
        
        # Get repo-specific configuration
        repo_config = get_repository_config(repository)
        project = repo_config.project
        
        try:
            # Get Git client from the repository-specific connection
            git_client = self.connections[repository].clients.get_git_client()
            
            # Get item content - using separate parameters instead of a dictionary for version control
            item = git_client.get_item_content(
                repository_id=repository,
                path=file_path,
                project=project,
            )
            
            # Try to decode as text (UTF-8)
            try:
                content = self.minify_code(b''.join(item).decode('utf-8'))
                is_binary = False
            except UnicodeDecodeError:
                # If it's not text, encode as base64
                is_binary = True
            
            return {
                "status": "success",
                "path": file_path,
                "length": len(content),
                "content": content,
            }
            
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "path": file_path,
                "repository": repository,
                "branch": branch            }

    async def get_file_content_rest(self, repository: str, file_path: str, branch: Optional[str] = None) -> Dict:
        """
        Get the content of a file from a repository using REST API (async version with httpx)
        
        Args:
            repository: Repository name
            file_path: Path to the file in the repository
            branch: Branch name (overrides repository default if provided)
            
        Returns:
            Dictionary containing the file content and status
        """
        self._ensure_valid_token(repository)
        
        repo_config = get_repository_config(repository)
        organization = repo_config.organization
        project = repo_config.project
        
        try:
            import httpx
              # Use provided branch or fall back to repository's configured branch
            used_branch = branch if branch is not None else repo_config.branch
            
            url = f"https://dev.azure.com/{organization}/{project}/_apis/git/repositories/{repository}/items"
            params = {
                "path": file_path,
                "versionDescriptor.version": used_branch,
                "includeContent": "true",
                "api-version": "7.1-preview.1"
            }
            headers = {
                "Authorization": f"Bearer {self.tokens[repository]}"
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.get(url, headers=headers, params=params)
                response.raise_for_status()
                content = self.minify_code(response.text)
                
                return {
                    "status": "success",
                    "path": file_path,
                    "length": len(content),
                    "content": content,
                }
            
        except Exception as e:
            logging.error(f"Error in get_file_content_rest: {str(e)}")
            content_result = self.get_file_content(repository, file_path, branch)
            if content_result["status"] == "success":
                logging.warning(f"fetch by get_file_content: {str(e)}")
                return content_result
            return {
                "status": "error",
                "message": str(e),
                "path": file_path,
                "repository": repository,
                "branch": branch
            }
    
    def get_wiki_client(self):
        """Get the Wiki client from Azure DevOps connection"""
        self._ensure_valid_token()
        return self.connections['AdsAppsMT'].clients.get_wiki_client()

    def search_wiki(self, search_text: str, max_results: int = 1000) -> Dict:
        """
        Search within wiki pages
        
        Args:
            search_text: Text to search for in wikis
            path: Optional path to filter results (only include results with this path)
            max_results: Maximum number of results to return (default: 1000)
            
        Returns:
            Dictionary containing search results and status
        """
        # Wiki operations use the default client
        self._ensure_valid_token()
        
        try:
            search_client = self.search_clients['AdsAppsMT']
            project = self.default_project
            
            # Create wiki search request
            search_request = {
                "searchText": search_text,
                "filters": {
                    "Project": [project],
                    "Wiki": ["eh-campaign-platform-teams-doc"]  
                },
                "top": max_results,
            }
            
            # Execute the search request
            response = search_client.fetch_wiki_search_results(search_request)
            
            # Filter results if path is specified
            if response.results:
                filtered_results = [
                    result for result in response.results 
                    if hasattr(result, 'path') and self.knowledge_base in result.path
                ]
            else:
                filtered_results = response.results

            wiki_client = self.get_wiki_client()
            
            for search_result in filtered_results:
                # Decode the base64 content if it's binary
                processed_file_name = search_result.file_name.replace('-', ' ').replace('.md', '')

                existing_page = wiki_client.get_page(project, self.wiki_id, f'/{self.knowledge_base}/{processed_file_name}', include_content=True)
                if existing_page:
                    search_result.content = existing_page.page.content

            return {
                "status": "success",
                "results": filtered_results,
                "count": len(filtered_results) if filtered_results else 0,
                "search_text": search_text,
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "search_text": search_text,
            }
    
    def get_wiki_pages_batch(self, wiki_id: str, filter_path: str) -> Dict:
        """
        Get wiki pages under a specific path in batches
        
        Args:
            wiki_id: ID of the wiki (defaults to self.wiki_id)
            path: Path in the wiki (default: root "/")
            batch_size: Number of pages to retrieve per batch (default: 100)
            
        Returns:
            Dictionary containing all wiki pages and status
        """
        self._ensure_valid_token()
        project = self.default_project
        
        try:
            wiki_client = self.get_wiki_client()
            all_pages = []
            continuation_token = None
            batch = 100
            
            # Get batch of pages
            batch = wiki_client.get_pages_batch(
                project=project,
                pages_batch_request=WikiPagesBatchRequest(
                    continuation_token=continuation_token,
                    top=batch,  # Number of pages to retrieve in each batch
                ),
                wiki_identifier=wiki_id
            )
            # Get content for each page in the batch
            for page in batch:
                content = wiki_client.get_page_by_id(project, wiki_id, page.id, include_content=True)
                if filter_path in content.page.path:
                    content.page.file_name = content.page.path
                    all_pages.append(content.page)
                
            return {
                "status": "success",
                "results": all_pages,
                "count": len(all_pages),
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
            }
    
    def save_wiki_page(self, title: str, content: str) -> Dict:
        """
        Save or update a wiki page
        
        Args:
            title: Title of the wiki page
            content: Content to save
            
        Returns:
            Dictionary containing the save status and page info
        """
        self._ensure_valid_token()
        project = self.default_project
        
        try:
            wiki_client = self.get_wiki_client()
            path = f'/{self.knowledge_base}/{title}'
            version = ""
            try:
                existing_page = wiki_client.get_page(project, self.wiki_id, path)
                version = existing_page.eTag
            except Exception as e:
                # Page doesn't exist, will create new
                pass

            parameters = WikiPageCreateOrUpdateParameters(
                content=content
            )
            version_descriptor = GitVersionDescriptor(
                version="main",
                version_type="branch"  # could also be "tag" or "commit"
            )
            
            page = wiki_client.create_or_update_page(
                parameters=parameters,
                project=project,
                wiki_identifier=self.wiki_id,
                path=path,
                version_descriptor=version_descriptor,
                version=version,  # Empty string for new pages, eTag for existing
            )
            
            return {
                "status": "success",
                "page": page,
                "path": path,
                "message": "Page saved successfully"
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "path": path
            }
    
    def delete_wiki_page(self, page_id: str) -> Dict:
        """
        Delete a wiki page by its ID
        
        Args:
            page_id: ID of the wiki page to delete
            
        Returns:
            Dictionary containing the deletion status
        """
        self._ensure_valid_token()
        project = self.default_project
        
        try:
            wiki_client = self.get_wiki_client()
            
            # Delete the page by ID
            wiki_client.delete_page_by_id(
                project=project,
                wiki_identifier=self.wiki_id,
                id=page_id
            )
            
            return {
                "status": "success",
                "message": f"Wiki page with ID {page_id} deleted successfully",
                "page_id": page_id
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "page_id": page_id
            }

# # Example usage
# if __name__ == "__main__":
#     # Initialize the search client using Azure CLI-based credentials
#     search_client = AzureDevOpsSearch(
#         organization="mscosmos",
#         project="CosmosWiki"
#     )

#     # search_client.get_wiki_pages('238b5bcf-c60f-4dad-bc05-fb4283e8d9ae')
#     search_client.get_wiki_pages_batch('238b5bcf-c60f-4dad-bc05-fb4283e8d9ae', 'SCOPE Language')
#     # path: /teams/CampaignMT/docs/team/Knowledge-Auto-Generated/
#     # wikiid: b499bcae-e563-4435-8427-585b129dd2f1
#     # search_client.search_wiki('video')
#     res = search_client.save_wiki_page('video resource2', 'Test conten2t fss')

#     search_client.delete_wiki_page(res['page'].page.id)
#     # # Example 1: Search in all repositories
#     # results = search_client.search_code(
#     #     search_text="(ext:cs OR ext:sql) video",
#     #     repository=["AdsAppsMT"],  # Search in specific repository
#     #     branch="master"
#     # )

#     # bar = search_client.get_file_content_from_results(results)
#     # print(bar)
import os
import base64
import re
import logging
import time
from typing import Optional, Dict, List
from dotenv import load_dotenv
from azure.devops.connection import Connection
from azure.identity import ManagedIdentityCredential, DefaultAzureCredential, InteractiveBrowserCredential
from msrest.authentication import BasicAuthentication
from azure.devops.v7_0.search.models import CodeSearchRequest
from azure.devops.v7_0.wiki.models import WikiPageCreateOrUpdateParameters, GitVersionDescriptor, WikiPagesBatchRequest
from src.configs.repository_configs import get_repository_config

# Load environment variables
load_dotenv()

class AzureDevOpsSearch:
    def __init__(self):
        """
        Initialize Azure DevOps search client
        
        Args:
            organization: Azure DevOps organization name
            project: Project name
        """
        self.knowledge_base = 'KnowledgeAutoGenerated'
        self.wiki_id = 'b499bcae-e563-4435-8427-585b129dd2f1'
        
        # Determine environment (production or development)
        environment = os.getenv('ENVIRONMENT', 'development').lower()
        
        # Select appropriate credential based on environment
        if environment == 'production' or environment == 'prod':
            # Use Managed Identity for production environments
            self.credential = ManagedIdentityCredential(client_id=os.getenv('CLIENT_ID'))
            print("Using ManagedIdentityCredential for production environment")
        else:
            # Use Interactive Browser for development environments
            self.credential = DefaultAzureCredential()
            print(f"Using InteractiveBrowserCredential for {environment} environment")
        
        # Initialize connection with fresh token
        self._refresh_connection()

    def _refresh_connection(self):
        """Refresh the Azure DevOps token and connection"""
        # Get new token for Azure DevOps
        self.token = self.credential.get_token('499b84ac-1321-427f-aa17-267ca6975798/.default').token
        # self.token = self.credential.get_token("https://msasg.visualstudio.com//.default").token        
        
        # Create a connection to Azure DevOps using token
        basic_auth = BasicAuthentication('', self.token)
        self.connection = Connection(base_url=f"https://dev.azure.com/{self.organization}", creds=basic_auth)
        
        # Get search client
        self.search_client = self.connection.clients.get_search_client()
          # Store token creation time
        self.token_created_at = time.time()
        logging.info("Azure DevOps token refreshed")

    def _ensure_valid_token(self):
        """Check if token is about to expire and refresh if needed"""
        # Refresh token if it's older than 45 minutes (before the typical 1 hour expiry)
        if time.time() - getattr(self, 'token_created_at', 0) > 45 * 60:
            logging.info("Token is about to expire, refreshing...")
            self._refresh_connection()

    def search_code(
        self,
        search_text: str,
        repository: Optional[str] = None,
        branch: Optional[str] = "master",
        agent_search: bool = False,
        max_results: int = 1000,
        without_prefix: bool = False
    ) -> Dict:
        """
        Search code in Azure DevOps repositories
        
        Args:
            search_text: Text to search for
            repository: Optional repository name to search in
            branch: Branch to search in (default: master)
            agent_search: Whether the search is performed by an agent (default: False)
            max_results: Maximum number of results to return (default: 1000)
            without_prefix: If True, repository-specific prefix will not be applied (default: False)
            
        Returns:
            Dictionary containing search results and status
        """
        self._ensure_valid_token()
        
        # Create search request filter
        search_filters = {
            "Project": [self.project]
        }
        
        # Clean up search text for path matching by removing file extension filters and other special syntax
        clean_search_text = search_text.lower()
        
        # Apply repository-specific configuration if repository is specified
        if repository:
            repository_name = repository
            repo_config = get_repository_config(repository_name)
            
            # Only apply prefix if without_prefix is False
            if not without_prefix:
                search_text = repo_config.apply_prefix(search_text)
            search_filters["Repository"] = repository if isinstance(repository, list) else [repository]
            
        if branch:
            search_filters["Branch"] = [branch]
        
        # Create search request
        search_request = CodeSearchRequest(
            search_text=search_text,
            filters=search_filters,
            top=max_results,
            include_snippet=True
        )
        
        try:
            # Execute the search request
            response = self.search_client.fetch_code_search_results(search_request)
            
            # Filter results based on repository configuration
            filtered_results = []
            
            for result in response.results:
                if not repository:
                    # Use default exclusions for non-repository-specific search
                    if not any(excluded in result.path.lower() for excluded in ['test', 'proxy', 'proxies']):
                        filtered_results.append(result)
                else:
                    # Use repository-specific configuration
                    repo_name = result.repository.name if hasattr(result, 'repository') and hasattr(result.repository, 'name') else None
                    if repo_name:
                        repo_config = get_repository_config(repo_name)
                        if not repo_config.should_exclude_path(result.path, agent_search):
                            filtered_results.append(result)
            
            # Sort results by prioritizing search text in path, then by content matches
            filtered_results.sort(
                key=lambda x: (
                    -int(clean_search_text in x.path.lower()),  # Priority to files with search text in path
                    -len(x.matches.get('content', []))         # Secondary sort by content matches
                )
            )
            
            return {
                "status": "success",
                "results": filtered_results,
                "count": len(filtered_results),
                "search_text": search_text
            }
            
        except Exception as e:
            logging.error(f"Error in search_code: {str(e)}, search_text: {search_text}")
            return {
                "status": "error",
                "message": str(e),
                "search_text": search_text
            }

    
    def minify_code(self, code):
        code = re.sub(r'\n\s*\n+', '\n', code)

        code = '\n'.join(line.strip() for line in code.splitlines())

        return code
    
    def get_file_content(self, repository: str, file_path: str, branch: str = "master") -> Dict:
        """
        Get the content of a file from a repository
        
        Args:
            repository: Repository name
            file_path: Path to the file in the repository
            branch: Branch name (default: main)
            
        Returns:
            Dictionary containing the file content and status
        """
        self._ensure_valid_token()
        
        try:
            # Get Git client
            git_client = self.connection.clients.get_git_client()
            
            # Get item content - using separate parameters instead of a dictionary for version control
            item = git_client.get_item_content(
                repository_id=repository,
                path=file_path,
                project=self.project,
            )
            
            # Try to decode as text (UTF-8)
            try:
                content = self.minify_code(b''.join(item).decode('utf-8'))
                is_binary = False
            except UnicodeDecodeError:
                # If it's not text, encode as base64
                is_binary = True
            
            return {
                "status": "success",
                "path": file_path,
                "length": len(content),
                "content": content,
            }
            
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "path": file_path,
                "repository": repository,
                "branch": branch
            }
    
    async def get_file_content_rest(self, repository: str, file_path: str, branch: str = "master") -> Dict:
        """
        Get the content of a file from a repository using REST API (async version with httpx)
        
        Args:
            repository: Repository name
            file_path: Path to the file in the repository
            branch: Branch name (default: master)
            
        Returns:
            Dictionary containing the file content and status
        """
        self._ensure_valid_token()
        
        try:
            import httpx
            
            url = f"https://dev.azure.com/{self.organization}/{self.project}/_apis/git/repositories/{repository}/items"
            params = {
                "path": file_path,
                "versionDescriptor.version": branch,
                "includeContent": "true",
                "api-version": "7.1-preview.1"
            }
            headers = {
                "Authorization": f"Bearer {self.token}"
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.get(url, headers=headers, params=params)
                response.raise_for_status()
                content = self.minify_code(response.text)
                
                return {
                    "status": "success",
                    "path": file_path,
                    "length": len(content),
                    "content": content,
                }
            
        except Exception as e:
            logging.error(f"Error in get_file_content_rest: {str(e)}")
            content_result = self.get_file_content(repository, file_path, branch)
            if content_result["status"] == "success":
                logging.warning(f"fetch by get_file_content: {str(e)}")
                return content_result
            return {
                "status": "error",
                "message": str(e),
                "path": file_path,
                "repository": repository,
                "branch": branch
            }

    def get_wiki_client(self):
        """Get the Wiki client from Azure DevOps connection"""
        self._ensure_valid_token()
        return self.connection.clients.get_wiki_client()

    def search_wiki(self, search_text: str, max_results: int = 1000) -> Dict:
        """
        Search within wiki pages
        
        Args:
            search_text: Text to search for in wikis
            path: Optional path to filter results (only include results with this path)
            max_results: Maximum number of results to return (default: 1000)
            
        Returns:
            Dictionary containing search results and status
        """
        self._ensure_valid_token("msasg")
        
        try:
            search_client = self.search_client
            
            # Create wiki search request
            search_request = {
                "searchText": search_text,
                "filters": {
                    "Project": [self.project],
                    "Wiki": ["eh-campaign-platform-teams-doc"]  
                },
                "top": max_results,
            }
            
            # Execute the search request
            response = search_client.fetch_wiki_search_results(search_request)
            
            # Filter results if path is specified
            if response.results:
                filtered_results = [
                    result for result in response.results 
                    if hasattr(result, 'path') and self.knowledge_base in result.path
                ]
            else:
                filtered_results = response.results

            wiki_client = self.get_wiki_client()
            
            for search_result in filtered_results:
                # Decode the base64 content if it's binary
                processed_file_name = search_result.file_name.replace('-', ' ').replace('.md', '')

                existing_page = wiki_client.get_page(self.project, self.wiki_id, f'/{self.knowledge_base}/{processed_file_name}', include_content=True)
                if existing_page:
                    search_result.content = existing_page.page.content

            return {
                "status": "success",
                "results": filtered_results,
                "count": len(filtered_results) if filtered_results else 0,
                "search_text": search_text,
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "search_text": search_text,
            }
    
    def get_wiki_pages_batch(self, wiki_id: str, filter_path: str) -> Dict:
        """
        Get wiki pages under a specific path in batches
        
        Args:
            wiki_id: ID of the wiki (defaults to self.wiki_id)
            path: Path in the wiki (default: root "/")
            batch_size: Number of pages to retrieve per batch (default: 100)
            
        Returns:
            Dictionary containing all wiki pages and status
        """
        self._ensure_valid_token("msasg")
        
        try:
            wiki_client = self.get_wiki_client()
            all_pages = []
            continuation_token = None
            batch = 100
            
            # Get batch of pages
            batch = wiki_client.get_pages_batch(
                project=self.project,
                pages_batch_request=WikiPagesBatchRequest(
                    continuation_token=continuation_token,
                    top=batch,  # Number of pages to retrieve in each batch
                ),
                wiki_identifier=wiki_id
            )
            # Get content for each page in the batch
            for page in batch:
                content = wiki_client.get_page_by_id(self.project, wiki_id, page.id, include_content=True)
                if filter_path in content.page.path:
                    content.page.file_name = content.page.path
                    all_pages.append(content.page)
                
            return {
                "status": "success",
                "results": all_pages,
                "count": len(all_pages),
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
            }

    def save_wiki_page(self, title: str, content: str) -> Dict:
        """
        Save or update a wiki page
        
        Args:
            wiki_id: ID of the wiki
            path: Path of the wiki page
            content: Content to save
            comment: Optional comment for the update
            
        Returns:
            Dictionary containing the save status and page info
        """
        self._ensure_valid_token("msasg")
        
        try:
            wiki_client = self.get_wiki_client()
            path = f'/{self.knowledge_base}/{title}'
            version = ""
            try:
                existing_page = wiki_client.get_page(self.project, self.wiki_id, path)
                version = existing_page.eTag
            except Exception as e:
                # Page doesn't exist, will create new
                pass

            parameters = WikiPageCreateOrUpdateParameters(
                content=content
            )
            version_descriptor = GitVersionDescriptor(
                version="main",
                version_type="branch"  # could also be "tag" or "commit"
            )
            
            page = wiki_client.create_or_update_page(
                parameters=parameters,
                project=self.project,
                wiki_identifier=self.wiki_id,
                path=path,
                version_descriptor=version_descriptor,
                version=version,  # Empty string for new pages, eTag for existing
            )
            
            return {
                "status": "success",
                "page": page,
                "path": path,
                "message": "Page saved successfully"
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "path": path
            }

    def delete_wiki_page(self, page_id: str) -> Dict:
        """
        Delete a wiki page by its ID
        
        Args:
            page_id: ID of the wiki page to delete
            
        Returns:
            Dictionary containing the deletion status
        """
        self._ensure_valid_token("msasg")
        
        try:
            wiki_client = self.get_wiki_client()
            
            # Delete the page by ID
            wiki_client.delete_page_by_id(
                project=self.project,
                wiki_identifier=self.wiki_id,
                id=page_id
            )
            
            return {
                "status": "success",
                "message": f"Wiki page with ID {page_id} deleted successfully",
                "page_id": page_id
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "page_id": page_id
            }

# # Example usage
# if __name__ == "__main__":
#     # Initialize the search client using Azure CLI-based credentials
#     search_client = AzureDevOpsSearch(
#         organization="mscosmos",
#         project="CosmosWiki"
#     )

#     # search_client.get_wiki_pages('238b5bcf-c60f-4dad-bc05-fb4283e8d9ae')
#     search_client.get_wiki_pages_batch('238b5bcf-c60f-4dad-bc05-fb4283e8d9ae', 'SCOPE Language')
#     # path: /teams/CampaignMT/docs/team/Knowledge-Auto-Generated/
#     # wikiid: b499bcae-e563-4435-8427-585b129dd2f1
#     # search_client.search_wiki('video')
#     res = search_client.save_wiki_page('video resource2', 'Test conten2t fss')

#     search_client.delete_wiki_page(res['page'].page.id)
#     # # Example 1: Search in all repositories
#     # results = search_client.search_code(
#     #     search_text="(ext:cs OR ext:sql) video",
#     #     repository=["AdsAppsMT"],  # Search in specific repository
#     #     branch="master"
#     # )

#     # bar = search_client.get_file_content_from_results(results)
#     # print(bar)